/* *********************************************************************
 * This Original Work is copyright of 51 Degrees Mobile Experts Limited.
 * Copyright 2025 51 Degrees Mobile Experts Limited, Davidson House,
 * Forbury Square, Reading, Berkshire, United Kingdom RG1 3EU.
 *
 * This Original Work is licensed under the European Union Public Licence (EUPL) 
 * v.1.2 and is subject to its terms as set out below.
 *
 * If a copy of the EUPL was not distributed with this file, You can obtain
 * one at https://opensource.org/licenses/EUPL-1.2.
 *
 * The 'Compatible Licences' set out in the Appendix to the EUPL (as may be
 * amended by the European Commission) shall be deemed incompatible for
 * the purposes of the Work and the provisions of the compatibility
 * clause in Article 5 of the EUPL shall not apply.
 * 
 * If using the Work as, or as part of, a network application, by 
 * including the attribution notice(s) required under Article 5 of the EUPL
 * in the end user terms of the application under an appropriate heading, 
 * such notice(s) shall fulfill the requirements of that article.
 * ********************************************************************* */

#include "pch.h"
#include "../src/wkbtot.h"

static bool CheckResult(const char *result, const char *expected, uint16_t const size) {
	bool match = true;
	for (uint16_t i = 0; i < size; i++) {
		match = match && (*result == *expected);
		result++;
		expected++;
	}
	return match;
}

static size_t constexpr DEFAULT_BUFFER_SIZE = 1024;

static void convertAndCompare(
	const uint8_t * const wkbBytes,
	const char * const expected,
	const char * const comment) {
	char buffer[DEFAULT_BUFFER_SIZE] = { 0 };
	FIFTYONE_DEGREES_EXCEPTION_CREATE;

	auto const result = fiftyoneDegreesConvertWkbToWkt(
		wkbBytes,
		buffer, std::size(buffer),
		exception);

	EXPECT_TRUE(FIFTYONE_DEGREES_EXCEPTION_OKAY) <<
		"Got exception while converting WKB: " << fiftyoneDegreesExceptionGetMessage(exception);

	EXPECT_FALSE(result.bufferTooSmall) <<
		"Buffer was deemed too small, requested " << result.written <<
		", available " <<  std::size(buffer);

	EXPECT_TRUE(
		CheckResult(buffer, expected, strlen(expected))) <<
		"The value of " << comment << " is not correctly converted -- '" << buffer <<
		"' -- vs expected -- '" << expected << "'";
}

TEST(WKBToT, WKBToT_Point_2D_NDR)
{
	const uint8_t wkbBytes[] = {
		0x00, // big endian
      	0x00,0x00,0x00,0x01, // POINT (2D)
        0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 2.0: x-coordinate
      	0x40,0x10,0x00,0x00,0x00,0x00,0x00,0x00, // 4.0: y-coordinate
    };
	const char * const expected = "Point(2 4)";

	convertAndCompare(wkbBytes, expected, "Point 2D (NDR)");
}

TEST(WKBToT, WKBToT_Point_2D_XDR)
{
	const uint8_t wkbBytes[] = {
		0x01,
		0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x31, 0x40,
	};
	const char * const expected = "Point(3.5 17.25)";

	convertAndCompare(wkbBytes, expected, "Point 2D (XDR)");
}

TEST(WKBToT, WKBToT_LineStringZ_XDR)
{
	const uint8_t wkbBytes[] = {
		0x01,
		0xea, 0x03, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x26, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x4f, 0x40,
		0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0x8b, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x30, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xcf, 0x67, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x23, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x71, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x37, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x3f,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
	};
	const char * const expected = "LineString Z("
	"2 11.125 63.0625, "
	"892.09375 16.28125 190.46875, "
	"9.59375 273.8125 23.15625, "
	"2.9375 0.3125 1)";

	convertAndCompare(wkbBytes, expected, "LineString Z (XDR)");
}

TEST(WKBToT, WKBToT_PolygonM_XDR)
{
	const uint8_t wkbBytes[] = {
		0x01,
		0xd3, 0x07, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x4f, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x4f, 0x40,
		0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x8b, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x67, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x71, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
	};
	const char * const expected = "Polygon M((2 -11 -63, -7 3 -5, 6 -9 17, -2 11 63), (892 16 190, 9 273 23, 2 0 1))";

	convertAndCompare(wkbBytes, expected, "Polygon M (XDR)");
}

TEST(WKBToT, WKBToT_TriangleZM_XDR)
{
	const uint8_t wkbBytes[] = {
		0x01,
		0xc9, 0x0b, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x40,
		0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0xc0,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x40,
	};
	const char * const expected = "Triangle ZM((-1 -1 1 1, 2 -2 2 2, -2 2 3 3), (-10 -10 10 10, 20 -20 20 20, -20 20 30 30))";

	convertAndCompare(wkbBytes, expected, "Triangle ZM (XDR)");
}

// Point (10 10)
//
// LineString ( 10 10, 20 20, 30 40)
//
// Polygon
// ((10 10, 10 20, 20 20, 20 15, 10 10))
//
// MultiPoint ((10 10), (20 20))
//
// MultiLineString
// (
// (10 10, 20 20), (15 15, 30 15)
// )
//
// MultiPolygon
// (
// ((10 10, 10 20, 20 20, 20 15, 10 10)),
// ((60 60, 70 70, 80 60, 60 60 ))
// )
//
// GeometryCollection
// (
// POINT (10 10),
// POINT (30 30),
// LINESTRING (15 15, 20 20)
// )
//
// Polyhedron Z
// (
// ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
// ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),
// ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),
// ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
// ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)),
// ((0 0 1, 1 0 1, 1 1 1, 0 1 1. 0 0 1))
// )
//
// Tin Z (
// ((0 0 0, 0 0 1, 0 1 0, 0 0 0)),
// ((0 0 0, 0 1 0, 1 0 0, 0 0 0)),
// ((0 0 0, 1 0 0, 0 0 1, 0 0 0)),
// ((1 0 0, 0 1 0, 0 0 1, 1 0 0)),
// )
//
// Point Z (10 10 5)
//
// Point ZM (10 10 5 40)
//
// Point M (10 10 40)
